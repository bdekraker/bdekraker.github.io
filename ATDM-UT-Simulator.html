<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultrasonic NDT Simulator + Realistic A‑Scan Spikes</title>
  <style>
    :root {
      --primary-bg: #1e1e1e;
      --secondary-bg: #2d2d2d;
      --tertiary-bg: #3c3c3c;
      --button-hover-bg: #4f4f4f;
      --text-color: #e0e0e0;
      --secondary-text-color: #b0b0b0; /* Added for the #b0b0b0 case */
      --accent-color: #007bff;
      --explanation-border: #0056b3;
      --correct-color: #28a745;
      --incorrect-color: #dc3545;
      --reveal-correct-border-color: #f0f0f0;
      --disabled-opacity: 0.7;
    }

    body {
      margin: 0;
      background: var(--primary-bg);
      color: var(--text-color);
      font-family: sans-serif;
    }

    #overallContainer {
      background-color: var(--secondary-bg);
      padding: 20px;
      border-radius: 15px;
      width: 800px;
      margin: 30px auto;
    }

    canvas {
      display: block;
    }

    #canvas { /* Main simulation canvas */
      background: var(--primary-bg); /* Or a slightly different dark shade if needed */
      margin-bottom: 10px;
      border: 1px solid var(--tertiary-bg); /* Optional: to define its edges */
    }

    #ascan { /* A-Scan display canvas */
      background: var(--secondary-bg); /* Consistent with containers */
      border-radius: 10px;
      border: 1px solid var(--tertiary-bg);
    }

    #instructionText {
      text-align: center;
      font-family: sans-serif;
      color: var(--secondary-text-color); /* Using the secondary text color */
      margin: 10px 0;
      font-size: 14px;
    }

    /* Realism Settings Panel Styles */
    #realismSettingsPanel {
      background-color: var(--tertiary-bg);
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .settings-group {
      display: flex;
      align-items: center;
      justify-content: space-between; /* Better alignment for label and switch */
      width: 90%; /* Or adjust as needed */
      gap: 15px;
      margin-bottom: 5px;
    }

    #realismSettingsPanel h4 {
      color: var(--accent-color); /* Title in accent color */
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 16px;
      text-align: center;
      width: 100%;
    }

    #realismSettingsPanel label {
      color: var(--text-color);
      font-size: 14px;
    }

    /* Toggle Switch CSS */
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 28px;
    }

    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--secondary-bg); /* Off state */
      -webkit-transition: .4s;
      transition: .4s;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 4px;
      bottom: 4px;
      background-color: var(--text-color); /* Knob color */
      -webkit-transition: .4s;
      transition: .4s;
    }

    input:checked + .slider {
      background-color: var(--accent-color); /* On state */
    }

    input:focus + .slider {
      box-shadow: 0 0 1px var(--accent-color);
    }

    input:checked + .slider:before {
      -webkit-transform: translateX(22px);
      -ms-transform: translateX(22px);
      transform: translateX(22px);
    }

    .slider.round {
      border-radius: 28px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    /* General Button Styles (if any are added later) */
    button, input[type="button"], input[type="submit"] {
      background-color: var(--accent-color);
      color: var(--text-color); 
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    button:hover, input[type="button"]:hover, input[type="submit"]:hover {
      background-color: var(--explanation-border); /* For primary action buttons */
    }
    button.secondary:hover { /* Example for general interactive elements hover */
        background-color: var(--button-hover-bg);
    }
    button:disabled, input[type="button"]:disabled, input[type="submit"]:disabled {
      opacity: var(--disabled-opacity);
      cursor: not-allowed;
      background-color: var(--tertiary-bg); 
    }

    /* Styles for quiz-like option buttons */
    .option-button {
      background-color: var(--tertiary-bg);
      color: var(--text-color);
      border: 1px solid var(--tertiary-bg);
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 5px;
      cursor: pointer;
      text-align: left;
      transition: background-color 0.3s ease, border-color 0.3s ease;
      display: block; 
      width: 100%; 
      box-sizing: border-box; 
    }
    .option-button:hover {
      background-color: var(--button-hover-bg);
      border-color: var(--accent-color); 
    }
    .option-button.correct {
      background-color: var(--correct-color);
      color: #ffffff; /* Ensuring good contrast on green */
      border-color: var(--correct-color);
    }
    .option-button.incorrect {
      background-color: var(--incorrect-color);
      color: #ffffff; /* Ensuring good contrast on red */
      border-color: var(--incorrect-color);
    }
    .option-button.reveal-correct { /* For showing the correct answer after a wrong pick */
      border: 2px dashed var(--reveal-correct-border-color);
      background-color: var(--tertiary-bg); 
      color: var(--text-color);
    }
    .option-button:disabled {
        opacity: var(--disabled-opacity);
        cursor: not-allowed;
        background-color: var(--tertiary-bg);
        color: var(--secondary-text-color);
    }

    /* Styles for feedback/explanation elements */
    .feedback-panel { 
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
        background-color: var(--secondary-bg);
    }
    .feedback-panel.correct {
      color: var(--correct-color);
      border-left: 4px solid var(--correct-color);
    }
    .feedback-panel.incorrect {
      color: var(--incorrect-color);
      border-left: 4px solid var(--incorrect-color);
    }
    .feedback-panel.explanation { 
      border-left: 4px solid var(--explanation-border);
      color: var(--text-color);
    }
  </style>
</head>
<body>
  <div id="overallContainer">
    <!-- main ray‑trace -->
    <canvas id="canvas" width="800" height="400"></canvas>
    <!-- Instructional Text -->
    <div id="instructionText">Slide the transducer above to simulate acoustics.</div>
    <!-- A‑scan display -->
    <canvas id="ascan"  width="800" height="200"></canvas>

    <!-- Realism Settings Panel -->
    <div id="realismSettingsPanel">
      <h4>Advanced Settings</h4>
      <div class="settings-group">
        <label for="toggleRepeatSignals">Show Repeat Signals:</label>
        <label class="switch">
          <input type="checkbox" id="toggleRepeatSignals" checked>
          <span class="slider round"></span>
        </label>
      </div>
      
      <div class="settings-group">
        <label for="toggleInitialPulse">Show Initial Pulse:</label>
        <label class="switch">
          <input type="checkbox" id="toggleInitialPulse" checked>
          <span class="slider round"></span>
        </label>
      </div>
      
      <div class="settings-group">
        <label for="toggleNoisySignals">Noisy Signals:</label>
        <label class="switch">
          <input type="checkbox" id="toggleNoisySignals" checked>
          <span class="slider round"></span>
        </label>
      </div>
      
      <div class="settings-group">
        <label for="toggleSolidSpikes">Solid Spikes:</label>
        <label class="switch">
          <input type="checkbox" id="toggleSolidSpikes">
          <span class="slider round"></span>
        </label>
      </div>

      <div class="settings-group">
        <label for="gainSlider">Gain (<span id="gainValue">1.0</span>x):</label>
        <input type="range" id="gainSlider" min="0.1" max="5.0" value="1.0" step="0.1" class="slider-control">
      </div>

      <div class="settings-group">
        <label for="rangeSlider">Range (<span id="rangeValue">1.0</span>x):</label>
        <input type="range" id="rangeSlider" min="0.25" max="4.0" value="1.0" step="0.05" class="slider-control">
      </div>
    </div>
  </div>

  <script>
  // ————— Math helpers —————
  function sub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function len(v){ return Math.hypot(v.x,v.y); }
  function normalize(v){
    const L=len(v);
    return L>0?{x:v.x/L,y:v.y/L}:{x:0,y:0};
  }
  function reflect(d,n){
    const dn=dot(d,n);
    return { x: d.x - 2*dn*n.x, y: d.y - 2*dn*n.y };
  }

  function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.arcTo(x + width, y, x + width, y + radius, radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
    ctx.lineTo(x + radius, y + height);
    ctx.arcTo(x, y + height, x, y + height - radius, radius);
    ctx.lineTo(x, y + radius);
    ctx.arcTo(x, y, x + radius, y, radius);
    ctx.closePath();
  }

  // ————— Configuration —————
  const CALCULATION_FREQUENCY = 5,  // Hz - For A-scan data updates
        CALCULATION_EMIT_PERIOD = 1 / CALCULATION_FREQUENCY,
        VISUAL_PULSE_FREQUENCY = 1, // Hz - For visual wave animations
        VISUAL_EMIT_PERIOD = 1 / VISUAL_PULSE_FREQUENCY,
        SPEED           = 100,      // px/sec = sound speed
        LIFETIME_FACTOR = 0.3,
        EPS             = 1e-3,
        DECAY           = 0.7,      // energy per bounce
        MAX_PULSES      = 5,        // recent pulses to remember
        MAX_DETECTED_REPEATS = 5, // Max times a wave reflects off transducer and re-enters
        INITIAL_MAX_TOF_DISPLAY = 20.0; // Base max time (seconds) to display on A-scan
  let currentMaxTofDisplay = INITIAL_MAX_TOF_DISPLAY; // Current max TOF, adjusted by rangeMultiplier

  // ————— Realism Settings —————
  const realismSettings = {
    frontFaceEnabled: true,    // From memory: for front-face reflection echo
    reverberationEnabled: true,  // From memory: for A-scan back-wall reverberations
    decayPerBounce: 0.8,       // From memory: decay factor for A-scan reverberations
    showRepeatSignals: true,     // New: for showing ray-traced repeat signals from transducer
    showInitialPulse: true,      // New: for showing the main bang/initial pulse
    noisySignalsEnabled: true,    // For baseline grass and signal jitter
    solidSpikesEnabled: false,    // Spikes are hollow by default
    gain: 1.0,                  // A-scan amplitude gain
    rangeMultiplier: 1.0        // A-scan time range multiplier
  };

  // ————— Canvas setup —————
  const canvas   = document.getElementById('canvas'),
        ctx      = canvas.getContext('2d'),
        ascan    = document.getElementById('ascan'),
        ascanCtx = ascan.getContext('2d');

  // ————— Scene geometry —————
  const part = { x:50, y:80, w:700, h:280 };
  let trans    = { x:canvas.width/2-40, y:part.y-20, w:80, h:20 };
  let dragging = false, dragOffX = 0;

  const flaws = [
    { type:'rectangle', x:150, y:160, w:60,  h:20 },
    { type:'circle',    cx:300, cy:200, radius:25 },
    { type:'polygon',   points:[
        {x:450,y:140},{x:520,y:150},{x:500,y:200},{x:430,y:190}
      ]
    },
    { type:'rectangle', x:600, y:220, w:50,  h:30 }
  ];

  // ————— Pulse tracking —————
  class Pulse {
    constructor(t0, rays){
      this.emissionTime = t0;
      this.echoes = [];

      // Add Initial Pulse if enabled
      if (realismSettings.showInitialPulse) {
        this.echoes.push({ tof: 0.001, amp: 0.9 }); // Strong pulse at the very beginning
      }

      rays.forEach(ray => {
        if (ray.detectedEchoes && ray.detectedEchoes.length > 0) {
          ray.detectedEchoes.forEach(echo => {
            const finalAmp = Math.max(0, echo.amp);
            if (finalAmp > 0.01) { // Only add echoes with significant amplitude
                this.echoes.push({
                    tof: echo.tof,
                    amp: finalAmp
                });
            }
          });
        }
      });
      this.echoes.sort((a,b) => a.tof - b.tof);

      // Note: MEMORY[87655c19-d956-4f7e-b144-e78b2d36aff6] (realismSettings)
      // previously modified this constructor for specific front-face/reverb effects.
      // The current changes implement a more fundamental, general reverberation.
      // If those realismSettings are still active and intended to provide
      // additional/different effects, further integration would be needed here.
    }
  }

  let lastEmission = -Infinity;
  let pulses = []; // Array to store active pulses for A-scan data
  let lastVisualEmission = -Infinity;
  let visualWaves = []; // Stores { emissionTime: t } for visual wave animations

  // Globals for A-scan animation
  let animatedEchoes = []; 
  const LERP_FACTOR = 0.15; // Interpolation speed (0 to 1, higher is faster) - Smoother, more gradual transitions
  const TOF_MATCH_THRESHOLD = 0.01; // Max TOF difference (seconds) to consider echoes the same
  let nextEchoId = 0; // For uniquely identifying animated echoes (optional, for debugging)

  // Noise generation state
  let noiseFrameCounter = 0;
  const NOISE_UPDATE_FRAME_INTERVAL = 8; // Update noise every N frames
  const FALSE_SPIKE_UPDATE_MULTIPLIER = 4; // False spikes update N times less often
  const LERP_FACTOR_FALSE_SPIKES = 0.1; // Animation speed for false spikes
  const LERP_FACTOR_SIGNAL_JITTER = 0.1; // Animation speed for real signal jitter
  let nextFalseSpikeId = 0;
  let currentBaselineNoiseOffsets = [];
  // currentAmplitudeJitterFactor and currentTofJitterOffset are now per-echo
  let currentFalseSpikes = []; // Stores {tof, ampFraction} for false noise spikes

  // ————— Mouse drag for transducer —————
  canvas.addEventListener('mousedown', e=>{
    const m=getMouse(e);
    const currentTopHatHeight = trans.h * 1.5;
            const currentTopHatY = trans.y - currentTopHatHeight;
            if(m.x >= trans.x && m.x <= trans.x + trans.w &&
               m.y >= currentTopHatY && m.y <= trans.y + trans.h){
      dragging=true; dragOffX=m.x-trans.x;
      canvas.style.cursor = 'grabbing'; // Set cursor to grabbing when drag starts
    }
  });
  canvas.addEventListener('mousemove', e=>{
    const m=getMouse(e);
    const currentTopHatHeight = trans.h * 1.5;
            const currentTopHatY = trans.y - currentTopHatHeight;
            const isOverTransducer = m.x >= trans.x && m.x <= trans.x + trans.w &&
                                     m.y >= currentTopHatY && m.y <= trans.y + trans.h;

    if(dragging){
      trans.x = Math.min(part.x+part.w-trans.w,
                         Math.max(part.x, m.x-dragOffX));
      // Cursor remains 'grabbing' as set on mousedown
    } else { // Not dragging
      if (isOverTransducer) {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'default';
      }
    }
  });
  ['mouseup','mouseleave'].forEach(evtName =>
    canvas.addEventListener(evtName, e => {
      if (evtName === 'mouseup') {
        const wasDragging = dragging; 
        dragging = false;
        if (wasDragging) { 
          const m = getMouse(e);
          const currentTopHatHeight = trans.h * 1.5;
                  const currentTopHatY = trans.y - currentTopHatHeight;
                  const isOverTransducer = m.x >= trans.x && m.x <= trans.x + trans.w &&
                                             m.y >= currentTopHatY && m.y <= trans.y + trans.h;
          canvas.style.cursor = isOverTransducer ? 'grab' : 'default';
        }
      } else if (evtName === 'mouseleave') {
        if (dragging) {
            dragging = false; 
        }
        canvas.style.cursor = 'default'; 
      }
    })
  );
  function getMouse(e){
    const r=canvas.getBoundingClientRect();
    return {
      x:(e.clientX-r.left)*(canvas.width/r.width),
      y:(e.clientY-r.top)*(canvas.height/r.height)
    };
  }

  // ————— Ray‑tracer (unchanged) —————
  function computeRays(){
    const numRays=10, maxBounces=10,
          spread=20*Math.PI/180,
          cx=trans.x+trans.w/2, cy=trans.y+trans.h;
    const rays=[];
    for(let i=0;i<numRays;i++){
      const ang = -spread/2 + (i/(numRays-1))*spread;
      let dir=normalize({x:Math.sin(ang), y:Math.cos(ang)}),
        p={x:cx,y:cy}, energy=1;
    const detectedEchoes = []; // Store multiple echoes for this ray
    let detectedRepeatsCount = 0; // Count reflections off transducer
      const pts=[{...p}], segDirs=[], segE=[];
      for(let b=0;b<maxBounces;b++){
        let nearest={t:Infinity,type:null,side:null,normal:null};

        // bottom boundary
        if(dir.y>0){
          const t0=((part.y+part.h)-p.y)/dir.y;
          if(t0>EPS&&t0<nearest.t)
            nearest={t:t0,type:'boundary',side:'bottom'};
        }

        // flaws
        flaws.forEach(f=>{
          switch(f.type){
            case 'rectangle':
              [[1,0,f.x,true,f.y,f.y+f.h],
               [-1,0,f.x+f.w,true,f.y,f.y+f.h],
               [0,1,f.y,false,f.x,f.x+f.w],
               [0,-1,f.y+f.h,false,f.x,f.x+f.w]]
              .forEach(([nx,ny,c,vert,min,max])=>{
                let t0;
                if(vert){
                  if(dir.x===0) return;
                  t0=(c-p.x)/dir.x;
                  if(t0<=EPS||t0>=nearest.t) return;
                  const yh=p.y+dir.y*t0;
                  if(yh>=min-EPS&&yh<=max+EPS)
                    nearest={t:t0,type:'flaw',normal:{x:nx,y:ny}};
                } else {
                  if(dir.y===0) return;
                  t0=(c-p.y)/dir.y;
                  if(t0<=EPS||t0>=nearest.t) return;
                  const xh=p.x+dir.x*t0;
                  if(xh>=min-EPS&&xh<=max+EPS)
                    nearest={t:t0,type:'flaw',normal:{x:nx,y:ny}};
                }
              });
              break;
            case 'circle':
              const oc=sub(p,{x:f.cx,y:f.cy}),
                    bq=2*dot(oc,dir),
                    cq=dot(oc,oc)-f.radius*f.radius,
                    disc=bq*bq-4*cq;
              if(disc>=0){
                const sd=Math.sqrt(disc);
                let t0=(-bq-sd)/2;
                if(t0<=EPS) t0=(-bq+sd)/2;
                if(t0>EPS&&t0<nearest.t){
                  const hit={x:p.x+dir.x*t0,y:p.y+dir.y*t0},
                        nrm=normalize(sub(hit,{x:f.cx,y:f.cy}));
                  nearest={t:t0,type:'flaw',normal:nrm};
                }
              }
              break;
            case 'polygon':
              for(let k=0;k<f.points.length;k++){
                const p1=f.points[k], p2=f.points[(k+1)%f.points.length],
                      seg=sub(p2,p1),
                      rdx=p1.x-p.x, rdy=p1.y-p.y,
                      det=seg.x*dir.y-seg.y*dir.x;
                if(Math.abs(det)<=EPS) continue;
                const tRay=(rdx*(-seg.y)-rdy*(-seg.x))/
                           (dir.x*(-seg.y)-dir.y*(-seg.x));
                const uSeg=(dir.x*rdy-dir.y*rdx)/
                           (dir.x*(-seg.y)-dir.y*(-seg.x));
                if(tRay>EPS&&tRay<nearest.t&&uSeg>=0&&uSeg<=1){
                  const nrm=normalize({x:-(p2.y-p1.y),y:(p2.x-p1.x)});
                  nearest={t:tRay,type:'flaw',normal:nrm};
                }
              }
              break;
          }
        });

        // left/right walls
        if(dir.x<0){
          const t0=(part.x-p.x)/dir.x;
          if(t0>EPS&&t0<nearest.t){
            const yh=p.y+dir.y*t0;
            if(yh>=part.y-EPS&&yh<=part.y+part.h+EPS)
              nearest={t:t0,type:'boundary',side:'left'};
          }
        }
        if(dir.x>0){
          const t0=(part.x+part.w-p.x)/dir.x;
          if(t0>EPS&&t0<nearest.t){
            const yh=p.y+dir.y*t0;
            if(yh>=part.y-EPS&&yh<=part.y+part.h+EPS)
              nearest={t:t0,type:'boundary',side:'right'};
          }
        }

        // top / return (modified for multiple reflections)
      if(dir.y<0){ // Moving upwards
        const t0=(part.y-p.y)/dir.y; // Time to hit plane y = part.y
        if(t0>EPS && t0<nearest.t){
          const xh=p.x+dir.x*t0; // x-coordinate of hit on top surface
          // Check if hit is within the physical part boundaries
          if(xh >= part.x - EPS && xh <= part.x + part.w + EPS){
            // Hit is on the top surface of the part
            if(xh >= trans.x - EPS && xh <= trans.x + trans.w + EPS){ // Hit is ON THE TRANSDUCER
              // This is a detection point. Calculate TOF and add to detectedEchoes.
              let pathLengthToCurrent_p = 0;
              for(let k=0; k < pts.length - 1; k++) {
                  pathLengthToCurrent_p += len(sub(pts[k+1], pts[k]));
              }
              const totalPathToHit = pathLengthToCurrent_p + t0;
              const tofToHit = totalPathToHit / SPEED;
              
              // Condition for recording an echo:
              // 1. It's the first time this ray hits the transducer (detectedRepeatsCount is 0).
              // OR
              // 2. Repeat signals are enabled, and we haven't hit the max repeats for this ray.
              if (detectedRepeatsCount === 0 || (realismSettings.showRepeatSignals && detectedRepeatsCount < MAX_DETECTED_REPEATS)) {
                  detectedEchoes.push({ tof: tofToHit, amp: energy });
              }

              // Condition for reflecting and continuing the ray path:
              if (realismSettings.showRepeatSignals && detectedRepeatsCount < MAX_DETECTED_REPEATS) {
                  detectedRepeatsCount++; // Increment count *only if* it's going to reflect and continue.
                  nearest={t:t0, type:'boundary', side:'top_transducer_reflect'}; // Reflect for more repeats.
              } else {
                  // Repeats are OFF OR max repeats for this ray have been reached.
                  // Terminate ray path (absorbed by transducer).
                  nearest={t:t0, type:'return_max_repeats'};
              }
            } else {
              // Hit is on top surface BUT OUTSIDE transducer
              nearest={t:t0, type:'boundary', side:'top'};
            }
          }
        }
      }

        if(!isFinite(nearest.t)) break;

        segDirs.push({...dir});
        segE.push(energy);
        const hit={x:p.x+dir.x*nearest.t,y:p.y+dir.y*nearest.t};
        pts.push(hit);
        if(nearest.type==='return_max_repeats') break; // Stop if max repeats hit at transducer

        let N=nearest.normal;
        if(nearest.type==='flaw'&&dot(dir,N)>0) N={x:-N.x,y:-N.y};
        if(nearest.type==='boundary'){
          switch(nearest.side){
            case 'left':   N={x:1,y:0};  break;
            case 'right':  N={x:-1,y:0}; break;
            case 'top':    N={x:0,y:1};  break;
            case 'bottom': N={x:0,y:-1}; break;
          case 'top_transducer_reflect': N={x:0,y:1}; break; // Ray reflects downwards
        }
        }
        dir=reflect(dir,N);
        p={x:hit.x+dir.x*EPS,y:hit.y+dir.y*EPS};
        energy*=DECAY;
        if(energy<0.02) break;
      }

      // distances
      const cum=[0];
      for(let m=1;m<pts.length;m++){
        cum.push(cum[m-1]+len(sub(pts[m],pts[m-1])));
      }

      rays.push({
      pts, segDirs, segE, cum,
      detectedEchoes, // Pass the array of detected echoes
      finalTotalPath: cum[cum.length-1] // Keep total path for potential other uses/debugging
    });
    }
    return rays;
  }

  // Function to update and interpolate A-scan echoes for smooth animation
  function updateAndGetAnimatedEchoes(actualEchoes) {
    const newAnimatedEchoes = [];
    const matchedActualIndices = new Set();

    // Ensure all existing animatedEchoes (from global scope) have jitter properties before processing
    animatedEchoes.forEach(ae => {
        if (ae.targetAmplitudeJitterFactor === undefined) {
            ae.targetAmplitudeJitterFactor = 1.0;
            ae.currentAmplitudeJitterFactor = 1.0; // Initialize current too
        }
        if (ae.targetTofJitterOffset === undefined) {
            ae.targetTofJitterOffset = 0.0;
            ae.currentTofJitterOffset = 0.0; // Initialize current too
        }
        // Ensure amp and tof properties also exist, just in case, though less likely to be missing
        if (ae.currentAmp === undefined) ae.currentAmp = 0;
        if (ae.targetAmp === undefined) ae.targetAmp = 0;
        if (ae.currentTof === undefined) ae.currentTof = 0;
        if (ae.targetTof === undefined) ae.targetTof = 0;
    });

    // 1. Try to update existing animated echoes or mark them for removal
    animatedEchoes.forEach(animEcho => {
        let bestMatch = null;
        let smallestTofDiff = TOF_MATCH_THRESHOLD;
        let bestMatchIndex = -1;

        actualEchoes.forEach((actualEcho, index) => {
            if (matchedActualIndices.has(index)) return; // Already matched this actual echo

            const tofDiff = Math.abs(actualEcho.tof - animEcho.currentTof);
            if (tofDiff < smallestTofDiff) {
                smallestTofDiff = tofDiff;
                bestMatch = actualEcho;
                bestMatchIndex = index;
            }
        });

        if (bestMatch) {
            animEcho.targetAmp = bestMatch.amp;
            animEcho.targetTof = bestMatch.tof;
            // originalTof is kept from the echo's "birth" for consistent matching
            matchedActualIndices.add(bestMatchIndex);
            newAnimatedEchoes.push(animEcho);
        } else {
            // This animated echo has no match, so it's disappearing
            animEcho.targetAmp = 0;
            if (animEcho.currentAmp > 0.01) { // Keep it if still visible
                newAnimatedEchoes.push(animEcho);
            }
        }
    });

    // 2. Add new actual echoes that weren't matched
    actualEchoes.forEach((actualEcho, index) => {
        if (!matchedActualIndices.has(index)) {
            newAnimatedEchoes.push({
                id: nextEchoId++,
                currentAmp: 0, // Start new echoes with 0 amplitude
                targetAmp: actualEcho.amp,
                currentTof: actualEcho.tof, // New echoes appear at their target TOF
                targetTof: actualEcho.tof,
                originalTof: actualEcho.tof, // Store its first TOF for future matching
                // Initialize jitter properties for the new echo
                currentAmplitudeJitterFactor: 1.0,
                targetAmplitudeJitterFactor: 1.0,
                currentTofJitterOffset: 0.0,
                targetTofJitterOffset: 0.0
            });
            // If noise is enabled, set initial target jitter for the new echo and apply immediately
            const newEchoJustAdded = newAnimatedEchoes[newAnimatedEchoes.length-1];
            if (realismSettings.noisySignalsEnabled) {
                newEchoJustAdded.targetAmplitudeJitterFactor = 0.85 + Math.random() * 0.3;
                newEchoJustAdded.targetTofJitterOffset = (Math.random() - 0.5) * 0.025;
                newEchoJustAdded.currentAmplitudeJitterFactor = newEchoJustAdded.targetAmplitudeJitterFactor;
                newEchoJustAdded.currentTofJitterOffset = newEchoJustAdded.targetTofJitterOffset;
            }
        }
    });

    // 3. Perform interpolation for all echoes
    newAnimatedEchoes.forEach(animEcho => {
        animEcho.currentAmp += (animEcho.targetAmp - animEcho.currentAmp) * LERP_FACTOR;
        animEcho.currentTof += (animEcho.targetTof - animEcho.currentTof) * LERP_FACTOR;
        // Clamp amplitude if fading out
        if (animEcho.targetAmp === 0 && animEcho.currentAmp < 0.001) {
            animEcho.currentAmp = 0;
        }
    });

    // 4. Update global animatedEchoes list, filtering out fully faded echoes
    animatedEchoes = newAnimatedEchoes.filter(ae => !(ae.targetAmp === 0 && ae.currentAmp === 0));
    return animatedEchoes;
}

  // ————— Draw realistic A‑scan spikes —————
  // ————— Draw A‑scan with pointy triangular spikes —————
function drawAScan(displayEchoes) {
    const ascan = document.getElementById('ascan');
    const ctx2 = ascan.getContext('2d');
    const w = ascan.width;
    const h = ascan.height;
    const windowT = currentMaxTofDisplay; // Use the range-adjusted max TOF (seconds)

  // background
  ctx2.fillStyle   = '#003300';
  ctx2.fillRect(0, 0, w, h);

  // grid
  ctx2.strokeStyle = '#004400';
  ctx2.lineWidth   = 1;
  for(let x = 0; x <= w; x += 50){
    ctx2.beginPath();
    ctx2.moveTo(x, 0);
    ctx2.lineTo(x, h);
    ctx2.stroke();
  }
  for(let y = 0; y <= h; y += 20){
    ctx2.beginPath();
    ctx2.moveTo(0, y);
    ctx2.lineTo(w, y);
    ctx2.stroke();
  }

  // baseline
  const baseY = h * 0.8;
  ctx2.strokeStyle = '#00ff00';
  ctx2.beginPath();
  ctx2.moveTo(0, baseY);
  if (realismSettings.noisySignalsEnabled) {
    if (noiseFrameCounter % NOISE_UPDATE_FRAME_INTERVAL === 0 || currentBaselineNoiseOffsets.length === 0) {
        let rawOffsets = [];
        const grassDensity = 5;
        const grassAmplitude = 2.5;
        for (let x_seg = 0; x_seg <= w; x_seg += grassDensity) { // w is ascan.width
            rawOffsets.push((Math.random() - 0.5) * 2 * grassAmplitude);
        }

        // Smooth the raw offsets
        if (rawOffsets.length === 0) {
            currentBaselineNoiseOffsets = [];
        } else if (rawOffsets.length === 1) {
            currentBaselineNoiseOffsets = [rawOffsets[0]];
        } else { // 2 or more points for smoothing
            let smoothed = [];
            smoothed.push((rawOffsets[0] + rawOffsets[1]) / 2); // Smoothed first point
            for (let i = 1; i < rawOffsets.length - 1; i++) {
                smoothed.push((rawOffsets[i-1] + rawOffsets[i] + rawOffsets[i+1]) / 3); // Middle points
            }
            smoothed.push((rawOffsets[rawOffsets.length - 2] + rawOffsets[rawOffsets.length - 1]) / 2); // Smoothed last point
            currentBaselineNoiseOffsets = smoothed;
        }
    }

    ctx2.lineWidth   = 1; // Thinner for grass
    const grassDensity = 5; // Must match density used for populating currentBaselineNoiseOffsets
    currentBaselineNoiseOffsets.forEach((offset, index) => {
        const xPos = (index) * grassDensity;
        if (xPos <= w) { // Check to prevent drawing past canvas width if array is too long
             ctx2.lineTo(xPos, baseY + (offset * realismSettings.gain)); // Apply Gain to grass
        }
    });
    // Ensure the line connects to the very end using the last or a new random offset
    const lastX = (currentBaselineNoiseOffsets.length -1) * grassDensity;
    if (lastX < w) {
        const lastOffset = currentBaselineNoiseOffsets.length > 0 ? currentBaselineNoiseOffsets[currentBaselineNoiseOffsets.length -1] : 0;
        ctx2.lineTo(w, baseY + (lastOffset * realismSettings.gain)); // Apply Gain to last grass segment
    }
  } else {
    ctx2.lineWidth   = 2; // Original thickness for flat baseline
    ctx2.lineTo(w, baseY);
  }
  ctx2.stroke();

  // Draw False Spikes if noisy signals are enabled
  if (realismSettings.noisySignalsEnabled && currentFalseSpikes.length > 0) {
    ctx2.fillStyle = '#00b300'; // A slightly dimmer or different green for noise spikes
    const W_false = 2; // Half-width of false spikes, make them thin
    const maxSpikeHeightAbsolute = ascan.height * 0.2; // Max 20% of canvas height (increased)

    currentFalseSpikes.forEach(spike => {
      const x_false = (spike.tof / windowT) * w;
      // Use currentAmpFraction for animated height
      let finalFalseSpikeH = spike.currentAmpFraction * maxSpikeHeightAbsolute;
      finalFalseSpikeH *= realismSettings.gain; // Apply Gain to false spikes

      if (Math.abs(finalFalseSpikeH) > 0.5) { // Only draw if it's at least half a pixel high
        ctx2.beginPath();
        ctx2.moveTo(x_false - W_false, baseY);
        ctx2.lineTo(x_false, baseY - finalFalseSpikeH);
        ctx2.lineTo(x_false + W_false, baseY);
        ctx2.closePath();
        if (realismSettings.solidSpikesEnabled) {
            ctx2.fillStyle = '#00b300'; // Ensure fill color is set for solid false spikes
            ctx2.fill();
        } else {
            ctx2.strokeStyle = '#00b300'; // Ensure stroke color is set for hollow false spikes
            ctx2.stroke();
        }
      }
    });
  }

  // If no REAL echoes to display, nothing to draw for REAL spikes
  if (!displayEchoes || displayEchoes.length === 0) {
    return;
  }

  // The time window (windowT) is now defined at the beginning of drawAScan using MAX_TOF_DISPLAY.

  // draw pointy triangular spikes
  ctx2.fillStyle = '#00ff00';
  const W = 4; // half‑width of each triangle
  displayEchoes.forEach(echo => {
    // Skip drawing if amplitude is negligible
    if (echo.currentAmp < 0.01) return;

    let currentTofForDisplay = echo.currentTof;
    let amplitudeFactorToApply = 1.0;

    if (realismSettings.noisySignalsEnabled) {
        // LERP current jitter towards target jitter for this specific echo
        echo.currentAmplitudeJitterFactor += (echo.targetAmplitudeJitterFactor - echo.currentAmplitudeJitterFactor) * LERP_FACTOR_SIGNAL_JITTER;
        echo.currentTofJitterOffset += (echo.targetTofJitterOffset - echo.currentTofJitterOffset) * LERP_FACTOR_SIGNAL_JITTER;

        currentTofForDisplay += echo.currentTofJitterOffset;
        amplitudeFactorToApply = echo.currentAmplitudeJitterFactor;
    } else {
        // Reset jitter properties if noise is turned off
        echo.currentAmplitudeJitterFactor = 1.0;
        echo.targetAmplitudeJitterFactor = 1.0;
        echo.currentTofJitterOffset = 0.0;
        echo.targetTofJitterOffset = 0.0;
        // Original subtle flicker if noise is off
        amplitudeFactorToApply = 0.95 + Math.random() * 0.1;
    }


    const x0 = (currentTofForDisplay / windowT) * w;
    const effectiveAmp = echo.currentAmp * amplitudeFactorToApply;
    let spikeH = effectiveAmp * (baseY * 0.9);
    spikeH *= realismSettings.gain; // Apply Gain
    
    // Ensure spikeH is not negative
    const finalSpikeH = Math.max(0, spikeH);

    ctx2.beginPath();
    // Use finalSpikeH for drawing
    ctx2.moveTo(x0 - W,         baseY);
    ctx2.lineTo(x0,             baseY - finalSpikeH);
    ctx2.lineTo(x0 + W,         baseY);
    ctx2.closePath();
    if (realismSettings.solidSpikesEnabled) {
        ctx2.fill();
    } else {
        ctx2.stroke();
    }
  });
}


  // ————— Draw & animate —————
  function draw(ts){
    const t=ts/1000;

    noiseFrameCounter++;
    if (realismSettings.noisySignalsEnabled) {
        if (noiseFrameCounter % NOISE_UPDATE_FRAME_INTERVAL === 0) {
            // Update TARGET jitter factors for each animated echo
            animatedEchoes.forEach(echo => {
                echo.targetAmplitudeJitterFactor = 0.85 + Math.random() * 0.3; // e.g., 0.85 to 1.15
                echo.targetTofJitterOffset = (Math.random() - 0.5) * 0.025;     // e.g., +/- 0.0125s
            });
            // Baseline noise offsets will be (re)populated and smoothed in drawAScan when this condition is met.
        }

        // Generate new false spikes (less frequently)
        if (noiseFrameCounter % (NOISE_UPDATE_FRAME_INTERVAL * FALSE_SPIKE_UPDATE_MULTIPLIER) === 0) {
            // Mark existing false spikes to fade out first
            currentFalseSpikes.forEach(spike => spike.targetAmpFraction = 0);
            
            const numFalseSpikes = Math.floor(Math.random() * 5) + 3; // 3 to 7 false spikes
            // Generate new false spikes to grow in and add them to the array
            for (let i = 0; i < numFalseSpikes; i++) {
                currentFalseSpikes.push({
                    id: nextFalseSpikeId++,
                    tof: Math.random() * currentMaxTofDisplay, // Use range-adjusted max TOF for false spike positioning
                    currentAmpFraction: 0, // Start at zero amplitude
                    targetAmpFraction: Math.random() * (Math.random() < 0.7 ? 0.6 : 1.0) // Target random amplitude
                });
            }
        }

        // Animate (LERP) all false spikes every frame if noise is enabled
        if (currentFalseSpikes.length > 0) {
            currentFalseSpikes.forEach(spike => {
                spike.currentAmpFraction += (spike.targetAmpFraction - spike.currentAmpFraction) * LERP_FACTOR_FALSE_SPIKES;
            });
            // Remove spikes that have fully faded out
            currentFalseSpikes = currentFalseSpikes.filter(spike => !(spike.targetAmpFraction === 0 && Math.abs(spike.currentAmpFraction) < 0.01));
        }
    }

    // emit new pulse
    if(t-lastEmission>=CALCULATION_EMIT_PERIOD){
      lastEmission=t;
      const rays=computeRays();
      pulses.push(new Pulse(t, rays));
      if(pulses.length>MAX_PULSES) pulses.shift();
    }

      // Emit new VISUAL pulse for animation
      if (t - lastVisualEmission >= VISUAL_EMIT_PERIOD) {
        lastVisualEmission = t;
        visualWaves.push({ emissionTime: t });
        // Keep visualWaves array from growing too large
        const maxVisualWaves = Math.ceil(MAX_PULSES * (CALCULATION_FREQUENCY / VISUAL_PULSE_FREQUENCY)) + 2;
        if (visualWaves.length > maxVisualWaves) {
          visualWaves.shift();
        }
      }

    // clear main
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw block, flaws, transducer...
    // Part object with rounded corners
    ctx.fillStyle='#ccc';
    drawRoundedRect(ctx, part.x, part.y, part.w, part.h, 5);
    ctx.fill();
    ctx.strokeStyle='#888';
    // Redraw path for stroke as fill consumes it
    drawRoundedRect(ctx, part.x, part.y, part.w, part.h, 5);
    ctx.stroke();
    flaws.forEach(f=>{
      ctx.fillStyle='rgba(20, 20, 20, 0.85)'; /* Very dark gray for flaws */
      ctx.strokeStyle='#000000'; /* Black border for flaws */
      ctx.lineWidth=1;
      if(f.type==='rectangle'){
        ctx.fillRect(f.x,f.y,f.w,f.h);
        ctx.strokeRect(f.x,f.y,f.w,f.h);
      } else if(f.type==='circle'){
        ctx.beginPath();
        ctx.arc(f.cx,f.cy,f.radius,0,2*Math.PI);
        ctx.fill(); ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(f.points[0].x,f.points[0].y);
        f.points.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    });
    // "Top hat" part of the transducer
    const topHatHeight = trans.h * 1.5; // Doubled height
    const topHatWidth = trans.w * 0.6;  // Width of the top part
    const topHatX = trans.x + (trans.w - topHatWidth) / 2;
    const topHatY = trans.y - topHatHeight; // Position it on top of the base
    const topHatRadius = 3; // Less rounded

    ctx.fillStyle = '#555'; // Slightly different shade for the top part
    drawRoundedRect(ctx, topHatX, topHatY, topHatWidth, topHatHeight, topHatRadius);
    ctx.fill();
    ctx.strokeStyle = '#222';
    drawRoundedRect(ctx, topHatX, topHatY, topHatWidth, topHatHeight, topHatRadius);
    ctx.stroke();

    // Add checkered pattern to top hat
    ctx.save();
    // Re-apply clipping path for the rounded rectangle
    drawRoundedRect(ctx, topHatX, topHatY, topHatWidth, topHatHeight, topHatRadius);
    ctx.clip();

    const checkerSize = 4;
    const color1 = '#4a4a4a'; // Darker gray for checker
    const color2 = '#606060'; // Lighter gray for checker

    for (let y = topHatY; y < topHatY + topHatHeight; y += checkerSize) {
      for (let x = topHatX; x < topHatX + topHatWidth; x += checkerSize) {
        // Determine color based on position to create checkerboard
        // Ensure we are using integer division for checkerboard logic
        const row = Math.floor((y - topHatY) / checkerSize);
        const col = Math.floor((x - topHatX) / checkerSize);
        ctx.fillStyle = (row + col) % 2 === 0 ? color1 : color2;
        ctx.fillRect(x, y, checkerSize, checkerSize);
      }
    }
    ctx.restore();

    // Original transducer base (the "brim")
    ctx.fillStyle='#444';
    ctx.fillRect(trans.x,trans.y,trans.w,trans.h);
    ctx.strokeStyle='#000';
    ctx.strokeRect(trans.x,trans.y,trans.w,trans.h);
    // Add text to transducer
    ctx.fillStyle = '#d3d3d3'; // Light gray text
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('TRANSDUCER', trans.x + trans.w / 2, trans.y + trans.h / 2);

    // draw rays & animated pulses (as before)...
    const rays=computeRays();
    const allFinalPaths = rays.map(r => r.finalTotalPath);
    const maxTotal = allFinalPaths.length > 0 ? Math.max(0, ...allFinalPaths) : 0; // Added Math.max(0,...) for safety
    const fullTime = maxTotal / SPEED;

    // Get all TOFs from the latest pulse for lifetime calculation
    const latestPulseEchoTofs = (pulses.length > 0 && pulses[pulses.length - 1].echoes)
                               ? pulses[pulses.length - 1].echoes.map(e => e.tof)
                               : [];
    const minDetectedTof = latestPulseEchoTofs.length > 0 ? Math.min(...latestPulseEchoTofs) : 0;
    const lifetime = Math.max(fullTime * LIFETIME_FACTOR, minDetectedTof + 0.05);

    // filter by lifetime
    pulses = pulses.filter(p=> t - p.emissionTime <= lifetime);
    visualWaves = visualWaves.filter(vw => t - vw.emissionTime <= lifetime); // Filter visual waves by the same lifetime

    // static skeleton
    rays.forEach(ray=>{
      const hasDetections = ray.detectedEchoes && ray.detectedEchoes.length > 0;
      const [r,g,b] = hasDetections ? [0,0,255] : [0,0,0]; // Blue if detected, else black
      ray.pts.slice(0,-1).forEach((p0,i)=>{
        const p1=ray.pts[i+1], alpha=ray.segE[i]*0.4;
        ctx.beginPath();
        ctx.strokeStyle=`rgba(${r},${g},${b},${alpha})`;
        ctx.moveTo(p0.x,p0.y);
        ctx.lineTo(p1.x,p1.y);
        ctx.stroke();
      });
    });

    // animated pulses
    rays.forEach(ray=>{
      visualWaves.forEach(vw=>{ // Iterate visualWaves for animation
        const age=t-vw.emissionTime; // Use emissionTime from visualWave
        if(age<0||age>lifetime) return;
        const d=age*SPEED;
        if(d>ray.finalTotalPath) return;
        let idx=ray.cum.findIndex(c=>c>=d);
        idx=idx<1?1:idx;
        const d0=ray.cum[idx-1], d1=ray.cum[idx],
              frac=(d-d0)/(d1-d0),
              p0=ray.pts[idx-1], p1=ray.pts[idx],
              x=p0.x+(p1.x-p0.x)*frac,
              y=p0.y+(p1.y-p0.y)*frac,
              dir=ray.segDirs[idx-1],
              perp=normalize({x:-dir.y,y:dir.x}),
              E=ray.segE[idx-1],
              fade=1-(age/lifetime),
              alpha=E*fade;
        if(alpha<0.01) return;
        const [cr,cg,cb]=dir.y<0?[0,0,255]:[0,0,0];

        const L=20,A=L*0.1,N=16;
        ctx.beginPath();
        for(let j=0;j<=N;j++){
          const u=j/N,u2=u-0.5,
                bx=x+perp.x*(u2*L),
                by=y+perp.y*(u2*L),
                bulge=A*(1-4*u2*u2),
                px=bx+dir.x*bulge,
                py=by+dir.y*bulge;
          if(j===0) ctx.moveTo(px,py);
          else      ctx.lineTo(px,py);
        }
        ctx.strokeStyle=`rgba(${cr},${cg},${cb},${alpha})`;
        ctx.lineWidth=2;
        ctx.stroke();
      });
    });

    // Update and get animated echoes for A-scan
  const actualEchoes = (pulses.length > 0 && pulses[pulses.length - 1].echoes) ? pulses[pulses.length - 1].echoes : [];
  const displayEchoesForAScan = updateAndGetAnimatedEchoes(actualEchoes);

  // draw the realistic A-scan spikes
  drawAScan(displayEchoesForAScan);

  requestAnimationFrame(draw);
  }

  // Event Listener for the toggle switch
  const toggleRepeatSignalsSwitch = document.getElementById('toggleRepeatSignals');
  if (toggleRepeatSignalsSwitch) {
    toggleRepeatSignalsSwitch.checked = realismSettings.showRepeatSignals;
    toggleRepeatSignalsSwitch.addEventListener('change', function() {
      realismSettings.showRepeatSignals = this.checked;
      // Optional: force a redraw or re-computation if needed immediately
      // lastEmission = -Infinity; // To force new pulse on next frame if transducer hasn't moved
      // requestAnimationFrame(draw); // if draw isn't already continuously running
    });
  }

  // Event Listener for the initial pulse toggle switch
  const toggleInitialPulseSwitch = document.getElementById('toggleInitialPulse');
  if (toggleInitialPulseSwitch) {
    toggleInitialPulseSwitch.checked = realismSettings.showInitialPulse;
    toggleInitialPulseSwitch.addEventListener('change', function() {
      realismSettings.showInitialPulse = this.checked;
    });
  }

  // Event Listener for the noisy signals toggle switch
  const toggleNoisySignalsSwitch = document.getElementById('toggleNoisySignals');
  if (toggleNoisySignalsSwitch) {
    toggleNoisySignalsSwitch.checked = realismSettings.noisySignalsEnabled;
    toggleNoisySignalsSwitch.addEventListener('change', function() {
      realismSettings.noisySignalsEnabled = this.checked;
    });
  }

  // Event Listener for the solid spikes toggle switch
  const toggleSolidSpikesSwitch = document.getElementById('toggleSolidSpikes');
  if (toggleSolidSpikesSwitch) {
    toggleSolidSpikesSwitch.checked = realismSettings.solidSpikesEnabled;
    toggleSolidSpikesSwitch.addEventListener('change', function() {
      realismSettings.solidSpikesEnabled = this.checked;
    });
  }

  // Event Listener for Gain slider
  const gainSlider = document.getElementById('gainSlider');
  const gainValueSpan = document.getElementById('gainValue');
  if (gainSlider && gainValueSpan) {
    gainSlider.value = realismSettings.gain;
    gainValueSpan.textContent = parseFloat(realismSettings.gain).toFixed(1);
    gainSlider.addEventListener('input', function() {
      realismSettings.gain = parseFloat(this.value);
      gainValueSpan.textContent = parseFloat(this.value).toFixed(1);
    });
  }

  // Event Listener for Range slider
  const rangeSlider = document.getElementById('rangeSlider');
  const rangeValueSpan = document.getElementById('rangeValue');
  if (rangeSlider && rangeValueSpan) {
    rangeSlider.value = realismSettings.rangeMultiplier;
    rangeValueSpan.textContent = parseFloat(realismSettings.rangeMultiplier).toFixed(2);
    rangeSlider.addEventListener('input', function() {
      realismSettings.rangeMultiplier = parseFloat(this.value);
      rangeValueSpan.textContent = parseFloat(this.value).toFixed(2);
      currentMaxTofDisplay = INITIAL_MAX_TOF_DISPLAY * realismSettings.rangeMultiplier;
    });
  }

  requestAnimationFrame(draw);
  </script>
</body>
</html>
