<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultrasonic NDT Simulator + Realistic A‑Scan Spikes</title>
  <style>
    body { margin:0; background:#313131; color: #f0f0f0; font-family: sans-serif; } /* Dark background, light text, default sans-serif */
    #overallContainer {
      background-color: #4a4a4a; /* Lighter gray than body */
      padding: 20px;
      border-radius: 15px;
      width: 800px; /* Content width, matches canvases */
      margin: 30px auto; /* Center container with top/bottom margin */
    }
    canvas { display:block; /* Remove general margin, handle specifically or by container */ }
    #canvas { 
      background:#313131; 
      margin-bottom: 10px; /* Space below main canvas */
    }
    #ascan { 
      background:#003300; 
      border-radius: 10px; /* Rounded corners for A-scan canvas */
    }
    #instructionText {
      text-align: center;
      font-family: sans-serif;
      color: #cccccc; /* Light gray text for contrast */
      margin: 10px 0; /* Provides space above and below */
      font-size: 14px;
    }

    /* Realism Settings Panel Styles */
    #realismSettingsPanel {
      background-color: #5a5a5a; /* Slightly lighter than overallContainer for contrast */
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      display: flex;
      flex-direction: column; /* Stack settings groups vertically */
      align-items: center;
      gap: 10px; /* Space between settings groups/items */
    }
    .settings-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 5px; /* Space below each individual setting line */
    }
    #realismSettingsPanel h4 {
      color: #e0e0e0;
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 16px;
      text-align: center;
      width: 100%;
    }
    #realismSettingsPanel label {
      color: #f0f0f0;
      font-size: 14px;
    }

    /* Toggle Switch CSS */
    .switch {
      position: relative;
      display: inline-block;
      width: 50px; /* Reduced width */
      height: 28px; /* Reduced height */
    }
    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #777; /* Darker gray when off */
      -webkit-transition: .4s;
      transition: .4s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 20px; /* Reduced knob height */
      width: 20px;  /* Reduced knob width */
      left: 4px;    /* Adjusted knob position */
      bottom: 4px;  /* Adjusted knob position */
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
    }
    input:checked + .slider {
      background-color: #007bff; /* Blue when on - can be changed */
    }
    input:focus + .slider {
      box-shadow: 0 0 1px #007bff;
    }
    input:checked + .slider:before {
      -webkit-transform: translateX(22px); /* Adjusted translation */
      -ms-transform: translateX(22px);
      transform: translateX(22px);
    }
    .slider.round {
      border-radius: 28px; /* Fully rounded */
    }
    .slider.round:before {
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div id="overallContainer">
    <!-- main ray‑trace -->
    <canvas id="canvas" width="800" height="400"></canvas>
    <!-- Instructional Text -->
    <div id="instructionText">Slide the transducer above to simulate acoustics.</div>
    <!-- A‑scan display -->
    <canvas id="ascan"  width="800" height="200"></canvas>

    <!-- Realism Settings Panel -->
    <div id="realismSettingsPanel">
      <h4>Advanced Settings</h4>
      <div class="settings-group">
        <label for="toggleRepeatSignals">Show Repeat Signals:</label>
        <label class="switch">
          <input type="checkbox" id="toggleRepeatSignals" checked>
          <span class="slider round"></span>
        </label>
      </div>
      
      <div class="settings-group">
        <label for="toggleInitialPulse">Show Initial Pulse:</label>
        <label class="switch">
          <input type="checkbox" id="toggleInitialPulse" checked>
          <span class="slider round"></span>
        </label>
      </div>
    </div>
  </div>

  <script>
  // ————— Math helpers —————
  function sub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function len(v){ return Math.hypot(v.x,v.y); }
  function normalize(v){
    const L=len(v);
    return L>0?{x:v.x/L,y:v.y/L}:{x:0,y:0};
  }
  function reflect(d,n){
    const dn=dot(d,n);
    return { x: d.x - 2*dn*n.x, y: d.y - 2*dn*n.y };
  }

  function drawRoundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.arcTo(x + width, y, x + width, y + radius, radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
    ctx.lineTo(x + radius, y + height);
    ctx.arcTo(x, y + height, x, y + height - radius, radius);
    ctx.lineTo(x, y + radius);
    ctx.arcTo(x, y, x + radius, y, radius);
    ctx.closePath();
  }

  // ————— Configuration —————
  const PULSE_FREQUENCY = 1,        // Hz
        EMIT_PERIOD     = 1/PULSE_FREQUENCY,
        SPEED           = 100,      // px/sec = sound speed
        LIFETIME_FACTOR = 0.3,
        EPS             = 1e-3,
        DECAY           = 0.7,      // energy per bounce
        MAX_PULSES      = 5,        // recent pulses to remember
        MAX_DETECTED_REPEATS = 5, // Max times a wave reflects off transducer and re-enters
        MAX_TOF_DISPLAY = 20.0; // Max time (seconds) to display on A-scan (increased for better echo separation)

  // ————— Realism Settings —————
  const realismSettings = {
    frontFaceEnabled: true,    // From memory: for front-face reflection echo
    reverberationEnabled: true,  // From memory: for A-scan back-wall reverberations
    decayPerBounce: 0.8,       // From memory: decay factor for A-scan reverberations
    showRepeatSignals: true,     // New: for showing ray-traced repeat signals from transducer
    showInitialPulse: true       // New: for showing the main bang/initial pulse
  };

  // ————— Canvas setup —————
  const canvas   = document.getElementById('canvas'),
        ctx      = canvas.getContext('2d'),
        ascan    = document.getElementById('ascan'),
        ascanCtx = ascan.getContext('2d');

  // ————— Scene geometry —————
  const part = { x:50, y:80, w:700, h:280 };
  let trans    = { x:canvas.width/2-40, y:part.y-20, w:80, h:20 };
  let dragging = false, dragOffX = 0;

  const flaws = [
    { type:'rectangle', x:150, y:160, w:60,  h:20 },
    { type:'circle',    cx:300, cy:200, radius:25 },
    { type:'polygon',   points:[
        {x:450,y:140},{x:520,y:150},{x:500,y:200},{x:430,y:190}
      ]
    },
    { type:'rectangle', x:600, y:220, w:50,  h:30 }
  ];

  // ————— Pulse tracking —————
  class Pulse {
    constructor(t0, rays){
      this.emissionTime = t0;
      this.echoes = [];

      // Add Initial Pulse if enabled
      if (realismSettings.showInitialPulse) {
        this.echoes.push({ tof: 0.001, amp: 0.9 }); // Strong pulse at the very beginning
      }

      rays.forEach(ray => {
        if (ray.detectedEchoes && ray.detectedEchoes.length > 0) {
          ray.detectedEchoes.forEach(echo => {
            const finalAmp = Math.max(0, echo.amp);
            if (finalAmp > 0.01) { // Only add echoes with significant amplitude
                this.echoes.push({
                    tof: echo.tof,
                    amp: finalAmp
                });
            }
          });
        }
      });
      this.echoes.sort((a,b) => a.tof - b.tof);

      // Note: MEMORY[87655c19-d956-4f7e-b144-e78b2d36aff6] (realismSettings)
      // previously modified this constructor for specific front-face/reverb effects.
      // The current changes implement a more fundamental, general reverberation.
      // If those realismSettings are still active and intended to provide
      // additional/different effects, further integration would be needed here.
    }
  }

  let lastEmission = -Infinity;
  let pulses = []; // Array to store active pulses

  // Globals for A-scan animation
  let animatedEchoes = []; 
  const LERP_FACTOR = 0.3; // Interpolation speed (0 to 1, higher is faster) - Increased for faster transitions
  const TOF_MATCH_THRESHOLD = 0.01; // Max TOF difference (seconds) to consider echoes the same
  let nextEchoId = 0; // For uniquely identifying animated echoes (optional, for debugging)

  // ————— Mouse drag for transducer —————
  canvas.addEventListener('mousedown', e=>{
    const m=getMouse(e);
    if(m.x>=trans.x&&m.x<=trans.x+trans.w
    && m.y>=trans.y&&m.y<=trans.y+trans.h){
      dragging=true; dragOffX=m.x-trans.x;
      canvas.style.cursor = 'grabbing'; // Set cursor to grabbing when drag starts
    }
  });
  canvas.addEventListener('mousemove', e=>{
    const m=getMouse(e);
    const isOverTransducer = m.x>=trans.x&&m.x<=trans.x+trans.w && m.y>=trans.y&&m.y<=trans.y+trans.h;

    if(dragging){
      trans.x = Math.min(part.x+part.w-trans.w,
                         Math.max(part.x, m.x-dragOffX));
      // Cursor remains 'grabbing' as set on mousedown
    } else { // Not dragging
      if (isOverTransducer) {
        canvas.style.cursor = 'grab';
      } else {
        canvas.style.cursor = 'default';
      }
    }
  });
  ['mouseup','mouseleave'].forEach(evtName =>
    canvas.addEventListener(evtName, e => {
      if (evtName === 'mouseup') {
        const wasDragging = dragging; 
        dragging = false;
        if (wasDragging) { 
          const m = getMouse(e);
          const isOverTransducer = m.x >= trans.x && m.x <= trans.x + trans.w && m.y >= trans.y && m.y <= trans.y + trans.h;
          canvas.style.cursor = isOverTransducer ? 'grab' : 'default';
        }
      } else if (evtName === 'mouseleave') {
        if (dragging) {
            dragging = false; 
        }
        canvas.style.cursor = 'default'; 
      }
    })
  );
  function getMouse(e){
    const r=canvas.getBoundingClientRect();
    return {
      x:(e.clientX-r.left)*(canvas.width/r.width),
      y:(e.clientY-r.top)*(canvas.height/r.height)
    };
  }

  // ————— Ray‑tracer (unchanged) —————
  function computeRays(){
    const numRays=10, maxBounces=10,
          spread=20*Math.PI/180,
          cx=trans.x+trans.w/2, cy=trans.y+trans.h;
    const rays=[];
    for(let i=0;i<numRays;i++){
      const ang = -spread/2 + (i/(numRays-1))*spread;
      let dir=normalize({x:Math.sin(ang), y:Math.cos(ang)}),
        p={x:cx,y:cy}, energy=1;
    const detectedEchoes = []; // Store multiple echoes for this ray
    let detectedRepeatsCount = 0; // Count reflections off transducer
      const pts=[{...p}], segDirs=[], segE=[];
      for(let b=0;b<maxBounces;b++){
        let nearest={t:Infinity,type:null,side:null,normal:null};

        // bottom boundary
        if(dir.y>0){
          const t0=((part.y+part.h)-p.y)/dir.y;
          if(t0>EPS&&t0<nearest.t)
            nearest={t:t0,type:'boundary',side:'bottom'};
        }

        // flaws
        flaws.forEach(f=>{
          switch(f.type){
            case 'rectangle':
              [[1,0,f.x,true,f.y,f.y+f.h],
               [-1,0,f.x+f.w,true,f.y,f.y+f.h],
               [0,1,f.y,false,f.x,f.x+f.w],
               [0,-1,f.y+f.h,false,f.x,f.x+f.w]]
              .forEach(([nx,ny,c,vert,min,max])=>{
                let t0;
                if(vert){
                  if(dir.x===0) return;
                  t0=(c-p.x)/dir.x;
                  if(t0<=EPS||t0>=nearest.t) return;
                  const yh=p.y+dir.y*t0;
                  if(yh>=min-EPS&&yh<=max+EPS)
                    nearest={t:t0,type:'flaw',normal:{x:nx,y:ny}};
                } else {
                  if(dir.y===0) return;
                  t0=(c-p.y)/dir.y;
                  if(t0<=EPS||t0>=nearest.t) return;
                  const xh=p.x+dir.x*t0;
                  if(xh>=min-EPS&&xh<=max+EPS)
                    nearest={t:t0,type:'flaw',normal:{x:nx,y:ny}};
                }
              });
              break;
            case 'circle':
              const oc=sub(p,{x:f.cx,y:f.cy}),
                    bq=2*dot(oc,dir),
                    cq=dot(oc,oc)-f.radius*f.radius,
                    disc=bq*bq-4*cq;
              if(disc>=0){
                const sd=Math.sqrt(disc);
                let t0=(-bq-sd)/2;
                if(t0<=EPS) t0=(-bq+sd)/2;
                if(t0>EPS&&t0<nearest.t){
                  const hit={x:p.x+dir.x*t0,y:p.y+dir.y*t0},
                        nrm=normalize(sub(hit,{x:f.cx,y:f.cy}));
                  nearest={t:t0,type:'flaw',normal:nrm};
                }
              }
              break;
            case 'polygon':
              for(let k=0;k<f.points.length;k++){
                const p1=f.points[k], p2=f.points[(k+1)%f.points.length],
                      seg=sub(p2,p1),
                      rdx=p1.x-p.x, rdy=p1.y-p.y,
                      det=seg.x*dir.y-seg.y*dir.x;
                if(Math.abs(det)<=EPS) continue;
                const tRay=(rdx*(-seg.y)-rdy*(-seg.x))/
                           (dir.x*(-seg.y)-dir.y*(-seg.x));
                const uSeg=(dir.x*rdy-dir.y*rdx)/
                           (dir.x*(-seg.y)-dir.y*(-seg.x));
                if(tRay>EPS&&tRay<nearest.t&&uSeg>=0&&uSeg<=1){
                  const nrm=normalize({x:-(p2.y-p1.y),y:(p2.x-p1.x)});
                  nearest={t:tRay,type:'flaw',normal:nrm};
                }
              }
              break;
          }
        });

        // left/right walls
        if(dir.x<0){
          const t0=(part.x-p.x)/dir.x;
          if(t0>EPS&&t0<nearest.t){
            const yh=p.y+dir.y*t0;
            if(yh>=part.y-EPS&&yh<=part.y+part.h+EPS)
              nearest={t:t0,type:'boundary',side:'left'};
          }
        }
        if(dir.x>0){
          const t0=(part.x+part.w-p.x)/dir.x;
          if(t0>EPS&&t0<nearest.t){
            const yh=p.y+dir.y*t0;
            if(yh>=part.y-EPS&&yh<=part.y+part.h+EPS)
              nearest={t:t0,type:'boundary',side:'right'};
          }
        }

        // top / return (modified for multiple reflections)
      if(dir.y<0){ // Moving upwards
        const t0=(part.y-p.y)/dir.y; // Time to hit plane y = part.y
        if(t0>EPS && t0<nearest.t){
          const xh=p.x+dir.x*t0; // x-coordinate of hit on top surface
          // Check if hit is within the physical part boundaries
          if(xh >= part.x - EPS && xh <= part.x + part.w + EPS){
            // Hit is on the top surface of the part
            if(xh >= trans.x - EPS && xh <= trans.x + trans.w + EPS){ // Hit is ON THE TRANSDUCER
              // This is a detection point. Calculate TOF and add to detectedEchoes.
              let pathLengthToCurrent_p = 0;
              for(let k=0; k < pts.length - 1; k++) {
                  pathLengthToCurrent_p += len(sub(pts[k+1], pts[k]));
              }
              const totalPathToHit = pathLengthToCurrent_p + t0;
              const tofToHit = totalPathToHit / SPEED;
              
              // Condition for recording an echo:
              // 1. It's the first time this ray hits the transducer (detectedRepeatsCount is 0).
              // OR
              // 2. Repeat signals are enabled, and we haven't hit the max repeats for this ray.
              if (detectedRepeatsCount === 0 || (realismSettings.showRepeatSignals && detectedRepeatsCount < MAX_DETECTED_REPEATS)) {
                  detectedEchoes.push({ tof: tofToHit, amp: energy });
              }

              // Condition for reflecting and continuing the ray path:
              if (realismSettings.showRepeatSignals && detectedRepeatsCount < MAX_DETECTED_REPEATS) {
                  detectedRepeatsCount++; // Increment count *only if* it's going to reflect and continue.
                  nearest={t:t0, type:'boundary', side:'top_transducer_reflect'}; // Reflect for more repeats.
              } else {
                  // Repeats are OFF OR max repeats for this ray have been reached.
                  // Terminate ray path (absorbed by transducer).
                  nearest={t:t0, type:'return_max_repeats'};
              }
            } else {
              // Hit is on top surface BUT OUTSIDE transducer
              nearest={t:t0, type:'boundary', side:'top'};
            }
          }
        }
      }

        if(!isFinite(nearest.t)) break;

        segDirs.push({...dir});
        segE.push(energy);
        const hit={x:p.x+dir.x*nearest.t,y:p.y+dir.y*nearest.t};
        pts.push(hit);
        if(nearest.type==='return_max_repeats') break; // Stop if max repeats hit at transducer

        let N=nearest.normal;
        if(nearest.type==='flaw'&&dot(dir,N)>0) N={x:-N.x,y:-N.y};
        if(nearest.type==='boundary'){
          switch(nearest.side){
            case 'left':   N={x:1,y:0};  break;
            case 'right':  N={x:-1,y:0}; break;
            case 'top':    N={x:0,y:1};  break;
            case 'bottom': N={x:0,y:-1}; break;
          case 'top_transducer_reflect': N={x:0,y:1}; break; // Ray reflects downwards
        }
        }
        dir=reflect(dir,N);
        p={x:hit.x+dir.x*EPS,y:hit.y+dir.y*EPS};
        energy*=DECAY;
        if(energy<0.02) break;
      }

      // distances
      const cum=[0];
      for(let m=1;m<pts.length;m++){
        cum.push(cum[m-1]+len(sub(pts[m],pts[m-1])));
      }

      rays.push({
      pts, segDirs, segE, cum,
      detectedEchoes, // Pass the array of detected echoes
      finalTotalPath: cum[cum.length-1] // Keep total path for potential other uses/debugging
    });
    }
    return rays;
  }

  // Function to update and interpolate A-scan echoes for smooth animation
  function updateAndGetAnimatedEchoes(actualEchoes) {
    const newAnimatedEchoes = [];
    const matchedActualIndices = new Set();

    // 1. Try to update existing animated echoes or mark them for removal
    animatedEchoes.forEach(animEcho => {
        let bestMatch = null;
        let smallestTofDiff = TOF_MATCH_THRESHOLD;
        let bestMatchIndex = -1;

        actualEchoes.forEach((actualEcho, index) => {
            if (matchedActualIndices.has(index)) return; // Already matched this actual echo

            const tofDiff = Math.abs(actualEcho.tof - animEcho.currentTof);
            if (tofDiff < smallestTofDiff) {
                smallestTofDiff = tofDiff;
                bestMatch = actualEcho;
                bestMatchIndex = index;
            }
        });

        if (bestMatch) {
            animEcho.targetAmp = bestMatch.amp;
            animEcho.targetTof = bestMatch.tof;
            // originalTof is kept from the echo's "birth" for consistent matching
            matchedActualIndices.add(bestMatchIndex);
            newAnimatedEchoes.push(animEcho);
        } else {
            // This animated echo has no match, so it's disappearing
            animEcho.targetAmp = 0;
            if (animEcho.currentAmp > 0.01) { // Keep it if still visible
                newAnimatedEchoes.push(animEcho);
            }
        }
    });

    // 2. Add new actual echoes that weren't matched
    actualEchoes.forEach((actualEcho, index) => {
        if (!matchedActualIndices.has(index)) {
            newAnimatedEchoes.push({
                id: nextEchoId++,
                currentAmp: 0, // Start new echoes with 0 amplitude
                targetAmp: actualEcho.amp,
                currentTof: actualEcho.tof, // New echoes appear at their target TOF
                targetTof: actualEcho.tof,
                originalTof: actualEcho.tof // Store its first TOF for future matching
            });
        }
    });

    // 3. Perform interpolation for all echoes
    newAnimatedEchoes.forEach(animEcho => {
        animEcho.currentAmp += (animEcho.targetAmp - animEcho.currentAmp) * LERP_FACTOR;
        animEcho.currentTof += (animEcho.targetTof - animEcho.currentTof) * LERP_FACTOR;
        // Clamp amplitude if fading out
        if (animEcho.targetAmp === 0 && animEcho.currentAmp < 0.001) {
            animEcho.currentAmp = 0;
        }
    });

    // 4. Update global animatedEchoes list, filtering out fully faded echoes
    animatedEchoes = newAnimatedEchoes.filter(ae => !(ae.targetAmp === 0 && ae.currentAmp === 0));
    return animatedEchoes;
}

  // ————— Draw realistic A‑scan spikes —————
  // ————— Draw A‑scan with pointy triangular spikes —————
function drawAScan(displayEchoes){ // Added displayEchoes parameter
  const w    = ascan.width;
  const h    = ascan.height;
  const ctx2 = ascanCtx;

  // background
  ctx2.fillStyle   = '#003300';
  ctx2.fillRect(0, 0, w, h);

  // grid
  ctx2.strokeStyle = '#004400';
  ctx2.lineWidth   = 1;
  for(let x = 0; x <= w; x += 50){
    ctx2.beginPath();
    ctx2.moveTo(x, 0);
    ctx2.lineTo(x, h);
    ctx2.stroke();
  }
  for(let y = 0; y <= h; y += 20){
    ctx2.beginPath();
    ctx2.moveTo(0, y);
    ctx2.lineTo(w, y);
    ctx2.stroke();
  }

  // baseline
  const baseY = h * 0.8;
  ctx2.strokeStyle = '#00ff00';
  ctx2.lineWidth   = 2;
  ctx2.beginPath();
  ctx2.moveTo(0, baseY);
  ctx2.lineTo(w, baseY);
  ctx2.stroke();

  // If no echoes to display, nothing to draw for spikes
  if (!displayEchoes || displayEchoes.length === 0) {
    return;
  }

  // Set a fixed time window to display multiple reverberations
  const windowT = 20.0; // Time window in seconds (e.g., to show up to ~3-4 backwall echoes)

  // draw pointy triangular spikes
  ctx2.fillStyle = '#00ff00';
  const W = 4; // half‑width of each triangle
  displayEchoes.forEach(echo => {
    // Skip drawing if amplitude is negligible
    if (echo.currentAmp < 0.01) return;

    const x0 = (echo.currentTof / windowT) * w; // Use interpolated TOF
    const flickerFactor = 0.95 + Math.random() * 0.1;
    const effectiveAmp = echo.currentAmp * flickerFactor; // Use interpolated amplitude with flicker
    const spikeH = effectiveAmp * (baseY * 0.9);
    
    // Ensure spikeH is not negative
    const finalSpikeH = Math.max(0, spikeH);

    ctx2.beginPath();
    // Use finalSpikeH for drawing
    ctx2.moveTo(x0 - W,         baseY);
    ctx2.lineTo(x0,             baseY - finalSpikeH);
    ctx2.lineTo(x0 + W,         baseY);
    ctx2.closePath();
    ctx2.fill();
  });
}


  // ————— Draw & animate —————
  function draw(ts){
    const t=ts/1000;

    // emit new pulse
    if(t-lastEmission>=EMIT_PERIOD){
      lastEmission=t;
      const rays=computeRays();
      pulses.push(new Pulse(t, rays));
      if(pulses.length>MAX_PULSES) pulses.shift();
    }

    // clear main
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw block, flaws, transducer...
    // Part object with rounded corners
    ctx.fillStyle='#ccc';
    drawRoundedRect(ctx, part.x, part.y, part.w, part.h, 5);
    ctx.fill();
    ctx.strokeStyle='#888';
    // Redraw path for stroke as fill consumes it
    drawRoundedRect(ctx, part.x, part.y, part.w, part.h, 5);
    ctx.stroke();
    flaws.forEach(f=>{
      ctx.fillStyle='rgba(150,0,0,0.7)'; /* Darker red for flaws */
      ctx.strokeStyle='#a00';
      ctx.lineWidth=1;
      if(f.type==='rectangle'){
        ctx.fillRect(f.x,f.y,f.w,f.h);
        ctx.strokeRect(f.x,f.y,f.w,f.h);
      } else if(f.type==='circle'){
        ctx.beginPath();
        ctx.arc(f.cx,f.cy,f.radius,0,2*Math.PI);
        ctx.fill(); ctx.stroke();
      } else {
        ctx.beginPath();
        ctx.moveTo(f.points[0].x,f.points[0].y);
        f.points.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
        ctx.closePath(); ctx.fill(); ctx.stroke();
      }
    });
    ctx.fillStyle='#444';
    ctx.fillRect(trans.x,trans.y,trans.w,trans.h);
    ctx.strokeStyle='#000';
    ctx.strokeRect(trans.x,trans.y,trans.w,trans.h);
    // Add text to transducer
    ctx.fillStyle = '#d3d3d3'; // Light gray text
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('TRANSDUCER', trans.x + trans.w / 2, trans.y + trans.h / 2);

    // draw rays & animated pulses (as before)...
    const rays=computeRays();
    const allFinalPaths = rays.map(r => r.finalTotalPath);
    const maxTotal = allFinalPaths.length > 0 ? Math.max(0, ...allFinalPaths) : 0; // Added Math.max(0,...) for safety
    const fullTime = maxTotal / SPEED;

    // Get all TOFs from the latest pulse for lifetime calculation
    const latestPulseEchoTofs = (pulses.length > 0 && pulses[pulses.length - 1].echoes)
                               ? pulses[pulses.length - 1].echoes.map(e => e.tof)
                               : [];
    const minDetectedTof = latestPulseEchoTofs.length > 0 ? Math.min(...latestPulseEchoTofs) : 0;
    const lifetime = Math.max(fullTime * LIFETIME_FACTOR, minDetectedTof + 0.05);

    // filter by lifetime
    pulses = pulses.filter(p=> t - p.emissionTime <= lifetime);

    // static skeleton
    rays.forEach(ray=>{
      const hasDetections = ray.detectedEchoes && ray.detectedEchoes.length > 0;
      const [r,g,b] = hasDetections ? [0,0,255] : [0,0,0]; // Blue if detected, else black
      ray.pts.slice(0,-1).forEach((p0,i)=>{
        const p1=ray.pts[i+1], alpha=ray.segE[i]*0.4;
        ctx.beginPath();
        ctx.strokeStyle=`rgba(${r},${g},${b},${alpha})`;
        ctx.moveTo(p0.x,p0.y);
        ctx.lineTo(p1.x,p1.y);
        ctx.stroke();
      });
    });

    // animated pulses
    rays.forEach(ray=>{
      pulses.forEach(pl=>{
        const age=t-pl.emissionTime;
        if(age<0||age>lifetime) return;
        const d=age*SPEED;
        if(d>ray.finalTotalPath) return;
        let idx=ray.cum.findIndex(c=>c>=d);
        idx=idx<1?1:idx;
        const d0=ray.cum[idx-1], d1=ray.cum[idx],
              frac=(d-d0)/(d1-d0),
              p0=ray.pts[idx-1], p1=ray.pts[idx],
              x=p0.x+(p1.x-p0.x)*frac,
              y=p0.y+(p1.y-p0.y)*frac,
              dir=ray.segDirs[idx-1],
              perp=normalize({x:-dir.y,y:dir.x}),
              E=ray.segE[idx-1],
              fade=1-(age/lifetime),
              alpha=E*fade;
        if(alpha<0.01) return;
        const [cr,cg,cb]=dir.y<0?[0,0,255]:[0,0,0];

        const L=20,A=L*0.1,N=16;
        ctx.beginPath();
        for(let j=0;j<=N;j++){
          const u=j/N,u2=u-0.5,
                bx=x+perp.x*(u2*L),
                by=y+perp.y*(u2*L),
                bulge=A*(1-4*u2*u2),
                px=bx+dir.x*bulge,
                py=by+dir.y*bulge;
          if(j===0) ctx.moveTo(px,py);
          else      ctx.lineTo(px,py);
        }
        ctx.strokeStyle=`rgba(${cr},${cg},${cb},${alpha})`;
        ctx.lineWidth=2;
        ctx.stroke();
      });
    });

    // Update and get animated echoes for A-scan
  const actualEchoes = (pulses.length > 0 && pulses[pulses.length - 1].echoes) ? pulses[pulses.length - 1].echoes : [];
  const displayEchoesForAScan = updateAndGetAnimatedEchoes(actualEchoes);

  // draw the realistic A-scan spikes
  drawAScan(displayEchoesForAScan);

  requestAnimationFrame(draw);
  }

  // Event Listener for the toggle switch
  const toggleRepeatSignalsSwitch = document.getElementById('toggleRepeatSignals');
  if (toggleRepeatSignalsSwitch) {
    toggleRepeatSignalsSwitch.checked = realismSettings.showRepeatSignals;
    toggleRepeatSignalsSwitch.addEventListener('change', function() {
      realismSettings.showRepeatSignals = this.checked;
      // Optional: force a redraw or re-computation if needed immediately
      // lastEmission = -Infinity; // To force new pulse on next frame if transducer hasn't moved
      // requestAnimationFrame(draw); // if draw isn't already continuously running
    });
  }

  // Event Listener for the initial pulse toggle switch
  const toggleInitialPulseSwitch = document.getElementById('toggleInitialPulse');
  if (toggleInitialPulseSwitch) {
    toggleInitialPulseSwitch.checked = realismSettings.showInitialPulse;
    toggleInitialPulseSwitch.addEventListener('change', function() {
      realismSettings.showInitialPulse = this.checked;
    });
  }

  requestAnimationFrame(draw);
  </script>
</body>
</html>
